# This is a part of rust-encoding.
# Copyright (c) 2013, Kang Seonghoon.
# See README.md and LICENSE.txt for details.

import urllib
import sys

def whatwg_index(name, comments):
    for line in urllib.urlopen('http://encoding.spec.whatwg.org/index-%s.txt' % name):
        line = line.strip()
        if not line: continue
        if line.startswith('#'):
            comments.append('//' + line[1:])
            continue
        parts = line.split(None, 2)
        key = int(parts[0], 0)
        value = int(parts[1], 0)
        yield key, value

def write_comma_separated(f, prefix, l, width=80):
    buffered = ''
    for i in l:
        i = str(i)
        if len(prefix) + len(buffered) + len(i) <= width:
            buffered += i
        else:
            print >>f, prefix + buffered.rstrip()
            buffered = i
    if buffered:
        print >>f, prefix + buffered.rstrip()

def generate_single_byte_index(name):
    data = [None] * 128
    comments = []
    for key, value in whatwg_index(name, comments):
        assert 0 <= key < 128 and 0 <= value < 0xffff and data[key] is None
        data[key] = value

    with open('%s.rs' % name.replace('-', '_'), 'wb') as f:
        print >>f, '// AUTOGENERATED FROM index-%s.txt, ORIGINAL COMMENT FOLLOWS:' % name
        print >>f, '//'
        for line in comments:
            print >>f, line
        print >>f
        print >>f, "static FORWARD_TABLE: &'static [u16] = &["
        write_comma_separated(f, '    ',
            ['%d, ' % (0xffff if value is None else value) for value in data])
        print >>f, '];'
        print >>f
        print >>f, '#[inline]'
        print >>f, 'pub fn forward(code: u8) -> u16 {'
        print >>f, '    FORWARD_TABLE[(code - 0x80) as uint]'
        print >>f, '}'
        print >>f
        print >>f, 'pub fn backward(code: u16) -> u8 {'
        print >>f, '    match code {'
        write_comma_separated(f, '        ',
            ['%d => %d, ' % (value, i+128) for i, value in enumerate(data) if value is not None] +
            ['_ => 0'])
        print >>f, '    }'
        print >>f, '}'
        print >>f
        print >>f, '#[cfg(test)]'
        print >>f, 'mod tests {'
        print >>f, '    use super::{forward, backward};'
        print >>f
        print >>f, '    #[test]'
        print >>f, '    fn test_correct_table() {'
        print >>f, '        for i in range(128, 256) {'
        print >>f, '            let i = i as u8;'
        print >>f, '            let j = forward(i);'
        print >>f, '            if j != 0xffff { assert_eq!(backward(j), i); }'
        print >>f, '        }'
        print >>f, '    }'
        print >>f, '}'

    return 2 * len(data)

def generate_multi_byte_index(name):
    data = {}
    invdata = {}
    dups = []
    comments = []
    morebits = False
    for key, value in whatwg_index(name, comments):
        assert 0 <= key < 0xffff and 0 <= value < 0x110000 and value != 0xffff and key not in data
        if value >= 0x10001:
            assert (value >> 16) == 2
            morebits = True
        data[key] = value
        if value not in invdata:
            invdata[value] = key
        else:
            dups.append(key)

    # Big5 has four two-letter forward mappings, we use special entries for them
    if name == 'big5':
        specialidx = [1133, 1135, 1164, 1166]
        assert all(key not in data for key in specialidx)
        assert all(value not in invdata for value in xrange(len(specialidx)))
        for value, key in enumerate(specialidx):
            data[key] = value
            dups.append(key) # no consistency testing for them

    # generate a trie with a minimal amount of data
    maxvalue = max(data.values()) + 1
    best = 0xffffffff
    besttrie = None
    for triebits in xrange(21):
        lower = [0xffff] * (1<<triebits)
        upper = []
        lowermap = {tuple(lower): 0}
        for i in xrange(0, maxvalue, 1<<triebits):
            blk = [invdata.get(j, 0xffff) for j in xrange(i, i + (1<<triebits))]
            loweridx = lowermap.get(tuple(blk))
            if loweridx is None:
                loweridx = len(lower)
                lowermap[tuple(blk)] = loweridx
                lower += blk
            upper.append(loweridx)
        if len(lower) < 0x10000 and best >= len(lower) + len(upper):
            best = len(lower) + len(upper)
            besttrie = (triebits, lower, upper)

    minkey = min(data)
    maxkey = max(data) + 1
    triebits, lower, upper = besttrie
    with open('%s.rs' % name.replace('-', '_'), 'wb') as f:
        print >>f, '// AUTOGENERATED FROM index-%s.txt, ORIGINAL COMMENT FOLLOWS:' % name
        print >>f, '//'
        for line in comments:
            print >>f, line
        print >>f
        print >>f, "static FORWARD_TABLE: &'static [u16] = &["
        write_comma_separated(f, '    ',
            ['%d, ' % (data.get(key, 0xffff) & 0xffff) for key in xrange(minkey, maxkey)])
        print >>f, '];'
        if morebits:
            print >>f
            print >>f, "static FORWARD_TABLE_MORE: &'static [u32] = &["
            bits = []
            for i in xrange(minkey, maxkey, 32):
                v = 0
                for j in xrange(32):
                    v |= (data.get(i+j, 0) >= 0x10000) << j
                bits.append(v)
            write_comma_separated(f, '    ', ['%d, ' % v for v in bits])
            print >>f, '];'
        print >>f
        print >>f, '#[inline]'
        print >>f, 'pub fn forward(code: u16) -> u32 {'
        if minkey != 0:
            print >>f, '    let code = (code - %d) as uint;' % minkey
        else:
            print >>f, '    let code = code as uint;'
        print >>f, '    if code < %d {' % (maxkey - minkey)
        if morebits:
            print >>f, '        (FORWARD_TABLE[code] as u32) | ' + \
                               '(((FORWARD_TABLE_MORE[code >> 5] >> (code & 31)) & 1) << 17)'
        else:
            print >>f, '        FORWARD_TABLE[code] as u32'
        print >>f, '    } else {'
        print >>f, '        0xffff'
        print >>f, '    }'
        print >>f, '}'
        print >>f
        print >>f, "static BACKWARD_TABLE_LOWER: &'static [u16] = &["
        write_comma_separated(f, '    ', ['%d, ' % v for v in lower])
        print >>f, '];'
        print >>f
        print >>f, "static BACKWARD_TABLE_UPPER: &'static [u16] = &["
        write_comma_separated(f, '    ', ['%d, ' % v for v in upper])
        print >>f, '];'
        print >>f
        print >>f, '#[inline]'
        print >>f, 'pub fn backward(code: u32) -> u16 {'
        print >>f, '    let offset = (code >> %d) as uint;' % triebits
        print >>f, '    let offset = if offset < %d {BACKWARD_TABLE_UPPER[offset] as uint} else {0};' % len(upper)
        print >>f, '    BACKWARD_TABLE_LOWER[offset + ((code & %d) as uint)]' % ((1<<triebits)-1)
        print >>f, '}'
        print >>f
        print >>f, '#[cfg(test)]'
        print >>f, 'mod tests {'
        print >>f, '    use super::{forward, backward};'
        print >>f
        print >>f, '    #[test]'
        print >>f, '    fn test_correct_table() {'
        print >>f, '        for i in range(0u32, 0x10000) {'
        print >>f, '            let i = i as u16;'
        for i in sorted(dups):
            print >>f, '            if i == %d { continue; }' % i
        print >>f, '            let j = forward(i);'
        print >>f, '            if j != 0xffff { assert_eq!(backward(j), i); }'
        print >>f, '        }'
        print >>f, '    }'
        print >>f, '}'

    tablesz = 2 * (maxkey - minkey) + 2 * len(lower) + 2 * len(upper)
    if morebits: tablesz += 4 * ((maxkey - minkey + 31) // 32)
    return tablesz

def generate_multi_byte_range_lbound_index(name):
    data = []
    comments = []
    for key, value in whatwg_index(name, comments):
        data.append((key, value))
    assert data and data == sorted(data)

    minkey, minvalue = data[0]
    maxkey, maxvalue = data[-1]
    if data[0] != (0, 0):
        data.insert(0, (0, 0))
    maxlog2 = 0
    while 2**(maxlog2 + 1) <= len(data):
        maxlog2 += 1

    with open('%s.rs' % name.replace('-', '_'), 'wb') as f:
        print >>f, '// AUTOGENERATED FROM index-%s.txt, ORIGINAL COMMENT FOLLOWS:' % name
        print >>f, '//'
        for line in comments:
            print >>f, line
        print >>f
        print >>f, "static FORWARD_TABLE: &'static [u32] = &["
        write_comma_separated(f, '    ', ['%d, ' % value for key, value in data])
        print >>f, '];'
        print >>f
        print >>f, "static BACKWARD_TABLE: &'static [u32] = &["
        write_comma_separated(f, '    ', ['%d, ' % key for key, value in data])
        print >>f, '];'
        print >>f
        print >>f, '#[inline]'
        print >>f, 'pub fn forward(code: u32) -> u32 {'
        if minkey > 0:
            print >>f, '    if code < %d { return 0xffffffff; }' % minkey
        if name == 'gb18030': # has "invalid" region inside
            print >>f, '    if (code > 39419 && code < 189000) || code > 1237575 { return 0xffffffff; }'
        print >>f, '    let mut i = if code >= BACKWARD_TABLE[%d] {%d} else {0};' % \
                (2**maxlog2 - 1, len(data) - 2**maxlog2 + 1)
        for i in xrange(maxlog2-1, -1, -1):
            print >>f, '    if code >= BACKWARD_TABLE[i%s] { i += %d; }' % \
                    ('+%d' % (2**i-1) if i > 0 else '', 2**i)
        print >>f, '    (code - BACKWARD_TABLE[i-1]) + FORWARD_TABLE[i-1]'
        print >>f, '}'
        print >>f
        print >>f, '#[inline]'
        print >>f, 'pub fn backward(code: u32) -> u32 {'
        if minvalue > 0:
            print >>f, '    if code < %d { return 0xffffffff; }' % minvalue
        print >>f, '    let mut i = if code >= FORWARD_TABLE[%d] {%d} else {0};' % \
                (2**maxlog2 - 1, len(data) - 2**maxlog2 + 1)
        for i in xrange(maxlog2-1, -1, -1):
            print >>f, '    if code >= FORWARD_TABLE[i%s] { i += %d; }' % \
                    ('+%d' % (2**i-1) if i > 0 else '', 2**i)
        print >>f, '    (code - FORWARD_TABLE[i-1]) + BACKWARD_TABLE[i-1]'
        print >>f, '}'
        print >>f
        print >>f, '#[cfg(test)]'
        print >>f, 'mod tests {'
        print >>f, '    use super::{forward, backward};'
        print >>f
        print >>f, '    #[test]'
        print >>f, '    fn test_no_failure() {'
        print >>f, '        for i in range(%du32, %d) {' % (max(0,minkey-1), maxkey+2)
        print >>f, '            forward(i);'
        print >>f, '        }'
        print >>f, '        for j in range(%du32, %d) {' % (max(0,minvalue-1), maxvalue+2)
        print >>f, '            backward(j);'
        print >>f, '        }'
        print >>f, '    }'
        print >>f
        print >>f, '    #[test]'
        print >>f, '    fn test_correct_table() {'
        print >>f, '        for i in range(%du32, %d) {' % (minkey, maxkey+2)
        print >>f, '            let j = forward(i);'
        print >>f, '            if j == 0xffffffff { continue; }'
        print >>f, '            let i_ = backward(j);'
        print >>f, '            if i_ == 0xffffffff { continue; }'
        print >>f, '            assert!(i_ == i, "backward(forward({})) = backward({}) = {} != {}", i, j, i_, i);'
        print >>f, '        }'
        print >>f, '    }'
        print >>f, '}'

    return 8 * len(data)

INDICES = {
    'ibm866':         generate_single_byte_index,
    'iso-8859-2':     generate_single_byte_index,
    'iso-8859-3':     generate_single_byte_index,
    'iso-8859-4':     generate_single_byte_index,
    'iso-8859-5':     generate_single_byte_index,
    'iso-8859-6':     generate_single_byte_index,
    'iso-8859-7':     generate_single_byte_index,
    'iso-8859-8':     generate_single_byte_index,
    'iso-8859-10':    generate_single_byte_index,
    'iso-8859-13':    generate_single_byte_index,
    'iso-8859-14':    generate_single_byte_index,
    'iso-8859-15':    generate_single_byte_index,
    'iso-8859-16':    generate_single_byte_index,
    'koi8-r':         generate_single_byte_index,
    'koi8-u':         generate_single_byte_index,
    'macintosh':      generate_single_byte_index,
    'windows-874':    generate_single_byte_index,
    'windows-1250':   generate_single_byte_index,
    'windows-1251':   generate_single_byte_index,
    'windows-1252':   generate_single_byte_index,
    'windows-1253':   generate_single_byte_index,
    'windows-1254':   generate_single_byte_index,
    'windows-1255':   generate_single_byte_index,
    'windows-1256':   generate_single_byte_index,
    'windows-1257':   generate_single_byte_index,
    'windows-1258':   generate_single_byte_index,
    'x-mac-cyrillic': generate_single_byte_index,

    'big5':           generate_multi_byte_index,
    'euc-kr':         generate_multi_byte_index,
    'gbk':            generate_multi_byte_index,
    'jis0208':        generate_multi_byte_index,
    'jis0212':        generate_multi_byte_index,

    'gb18030':        generate_multi_byte_range_lbound_index,
}

if __name__ == '__main__':
    import sys
    filter = sys.argv[1] if len(sys.argv) > 1 else ''
    for index, generate in INDICES.items():
        if filter not in index: continue
        print >>sys.stderr, 'generating index %s...' % index,
        tablesz = generate(index)
        print >>sys.stderr, '%d bytes.' % tablesz

